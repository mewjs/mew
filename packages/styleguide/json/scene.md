## 应用场景

### 健康检查

应用的健康检查，通常只需要校验完整输出与预期是否一致，并不需要处理响应的数据。

```json
// 正常：省略 code 与 data
{}

// 正常： 省略 data
{
    "code": 0
}

// 异常：不需要 info，根据 code 码值约定对应的错误
{
    "code": 1
}

// 异常：给出错误信息
{
    "code": 2,
    "info": "XXX 服务连接失败"
}

```

### 数据验证

基于所有用户输入均不可信的原则，因此服务端必须对输入数据作必要的校验。校验失败、确保安全前提下时尽可能给出对用户有帮助的详细信息。

Q：为什么需要返回提交的数据？

A：涉及到竞态条件（[Race Condition](https://en.wikipedia.org/wiki/Race_condition)）的问题。当出现多次不同的数据提交请求，受网络影响，响应时序与提交时序不一致，处理不当可能导致给予用户错误的反馈。解决方案是有新的请求时取消旧的未完成的请求，或者记录最后提交的数据，当返回数据不匹配时忽略。

```json
// 通过：不区分单多项数据
{
    "code": 0
}

// 通过：单项数据的提交校验结果，同时返回提交的数据
{
    "code": 0,
    "data": "foobar2000"
}

// 通过：单项数据的提交校验结果，同时返回提交的数据
{
    "code": 0,
    "data": "foobar2000"
}

// 通过：多项数据的提交校验结果，同时返回提交的数据
{
    "code": 0,
    "data": [
        {
            "loginName": "18888888888"
        },
        {
            "nickName": "foobar2000"
        }
    ]
}

// 失败：多项数据的提交校验结果，同时返回对应的提示信息
{
    "code": 456,
    "info": {
        "loginName": "不是有效的北京电信手机号码",
        "nickName": "'foobar' 已被注册，建议尝试 'foobar2000'"
    }
}

// 失败：多项数据的提交校验结果，同时返回提交的数据和提示信息（对象>数组）
{
    "code": 457,
    "info": {
        "loginName": ["18812345678", "不是有效的北京电信手机号码"],
        "nickName": ["foobar", "'foobar' 已被注册，建议尝试 'foobar2000'"]
    }
}

// 失败：多项数据的提交校验结果，同时返回提交的数据和提示信息（数组>对象）
{
    "code": 458,
    "info": [
        {
            "loginName": ["18812345678", "不是有效的北京电信手机号码"]
        },
        {
           "nickName": ["foobar", "'foobar' 已被注册，建议尝试 'foobar2000'"]
        }
    ]
}

// 失败：多项数据的提交校验结果，同时返回提交的数据和提示信息（数组>对象）
{
    "code": 459,
    "info": [
        {
            "name": "loginName",
            "value": "18812345678",
            "warning": "不是有效的北京电信手机号码"
        },
        {
            "name": "nickName",
            "value": "foobar",
            "warning": "'foobar' 已被注册，建议尝试 'foobar2000'"
        }
    ]
}
```

### 数据分页

在列表页面展示分页数据，是基础需求，可以有效避免用户一次载入过多数据带来不必要的性能开销。

基于前端分页组件的计算展示以及后端查询数据的需要，通常需要约定以下字段：

- **page（当前页）**：常用 `index`、`page`、`pageNo` 或 `pageIndex` 来表示，为了兼顾语义及准确性，我们建议使用 `page`
- **size（每页记录数）**：常用 `size` 或 `pageSize` 来表示，同样，我们建议使用 `size`
- **total（总记录数）**：常用 `total`、`totalPage`、`count` 或 `totalCount` 来表示，同样，我们建议使用 `total`
- **list（数据列表）**：常用 `data`、`list` 或业务模型的复数形式如 `articles`、`videos` 等，为了便于统一处理，我们建议使用 `list`，在消费时再通过参数或变量名换成业务模型的复数形式
- **keyword（关键词）**：有某些情况下，可能需要根据关键字查询，因此需要增加一个参数，常用 `key` 或 `keyword`，我们建议使用 `keyword`
- **filters（过滤条件）**：列表可能有针对多个字段的筛选条件，这时需要有一个对象类型的参数 `filters`
- **orderBy（排序）**：排序可能是一个字段，也可能是多个字段，而且各字段或升或降各异，因此建议使用 `"字段1 asc, 字段2 desc"` 或 `{"字段1": "asc", "字段2": "desc"}` 的方式，在对数据大小敏感的情况下也可以用 `1` 和 `0` 代替 `asc` 和 `desc`。

Q：为什么从前端传给接口的 **当前页**、**每页记录数**、**关键词** 仍需返回？

A：主要是避免给用户错误的反馈：一方面用户可能在不同页之间快速切换导致出现（[Race Condition](https://en.wikipedia.org/wiki/Race_condition)），另一方面用户可能输入非法的数据触发接口的默认值逻辑。

```json
// 没有记录的分页数据
{
    "code": 0,
    "data": {
        "page": 1,
        "size": 10,
        "total": 0,
        "list": []
    }
}

// 有记录的分页数据
{
    "code": 0,
    "data": {
        "page": 5,
        "size": 10,
        "total": 631,
        "list": [
            // 填充的数据实体对象
        ]
    }
}


// 带查询关键词的分页数据
{
    "code": 0,
    "data": {
        "page": 5,
        "size": 10,
        "total": 631,
        "keyword": "foobar",
        "list": [
            // 填充的数据实体对象
        ]
    }
}

// 带多个过滤条件的分页数据
{
    "code": 0,
    "data": {
        "page": 5,
        "size": 10,
        "total": 631,
        "filters": {
            "title": "foobar",
            "publishedAt": "last 7 days"
        },
        "list": [
            // 填充的数据实体对象
        ]
    }
}


```

### 树形数据

通常情况下，使用拍平的结构，数据量更小，但依赖于数据消费方自己恢复成树。

```json
// 拍平的树形数据
{
    "code": 0,
    "data": [
        {
            "id": 1,
            "name": "北京",
            "pid": 0
        },
        {
            "id": 2,
            "name": "上海",
            "pid": 0
        },
        // ...
        {
            "id": 100,
            "name": "海淀区",
            "pid": 1
        },
        {
            "id": 101,
            "name": "昌平区",
            "pid": 1
        },
        {
            "id": 206,
            "name": "上地街道",
            "pid": 100
        }
        // ...
    ]
}

// 保持树形的数据
{
    "code": 0,
    "data": [
        {
            "id": 1,
            "name": "北京",
            "children": [
                {
                    "id": 100,
                    "name": "海淀区",
                    "children": [
                        {
                            "id": 206,
                            "name": "上地街道",
                            "pid": 100
                        }
                        // ...
                    ]
                },
                {
                    "id": 101,
                    "name": "昌平区",
                    "children": [
                        // ...
                    ]
                }
                // ...
            ]
        },
        {
            "id": 2,
            "name": "上海",
            "children": [
                // ...
            ]
        },
        // ...
    ]
}
```
